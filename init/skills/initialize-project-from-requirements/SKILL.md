# Skill: initialize-project-from-requirements

This skill connects the end-to-end initialization flow:

`requirements docs -> project blueprint -> scaffold/config generation -> skills sync`

It records an auditable init state throughout the workflow so that each stage has an explicit **validate + user approval** checkpoint.

Goal: a robust, repeatable, rollback-friendly initialization workflow (not “fastest possible”).

---

## Inputs

### Stage A (requirements docs, required)

Working location (default: `init/stage-a-docs/`):

- `init/stage-a-docs/requirements.md`
- `init/stage-a-docs/non-functional-requirements.md`
- `init/stage-a-docs/domain-glossary.md`
- `init/stage-a-docs/risk-open-questions.md`

### Stage B (blueprint, required)

Working location (default): `init/project-blueprint.json`

> **Note**: After initialization completes, use `cleanup-init --archive` to move these files to `docs/project/` for long-term retention.

### Optional: add-on (Context Awareness)

If `blueprint.addons.contextAwareness: true`, the add-on payload must exist at:

- `<repoRoot>/<addonsRoot>/context-awareness/payload/`

Where `<addonsRoot>` defaults to `addons/` and can be overridden via `apply --addons-root`.

---

## Outputs (written to disk)

### Stage A

- Requirements docs (`docs/project/*`)
- Init state file: `init/.init-state.json`

### Stage B

- Blueprint: `docs/project/project-blueprint.json`

### Stage C

- Directory scaffold (examples):
  - `src/` or `apps/` + `packages/` (based on `repo.layout`)
  - `docs/diagrams/` (if diagram capability is enabled)
  - `ops/` (if DevOps scaffold is enabled; see below)
- Config files generated by `scripts/scaffold-configs.cjs` (for example `.gitignore`, lint/test/format configs, depending on the blueprint)
- Skills selection (SSOT):
  - `.ai/skills/_meta/sync-manifest.json` (flat schema: `version/includePrefixes/includeSkills/excludeSkills`)
  - Add-on mode: if `.ai/scripts/skillsctl.js` exists, pack toggles must be done via skillsctl (scheme A)
- Provider wrappers generated/updated:
  - `node .ai/scripts/sync-skills.cjs` (supports `--providers`)

### Optional: Context Awareness add-on artifacts

When Context Awareness is enabled and `apply` runs successfully, you will typically see:

- `.ai/scripts/contextctl.js`
- `.ai/scripts/projectctl.js`
- `docs/context/` (registries/workflows/etc., depending on the add-on implementation)

---

## Mandatory workflow rules

1. Every stage transition requires **validation + explicit user approval**.
   - Validation is recorded in `init/.init-state.json` by pipeline commands
   - Stage advancement must use `approve` (do not hand-edit the state file to “skip” stages)
2. Do not advance stages without explicit user approval.
3. Context Awareness add-on is installed **on demand**:
   - Only when `blueprint.addons.contextAwareness: true` will the pipeline attempt installation from `/addons/<addonId>/payload`
   - `blueprint.context.*` is configuration only and does not trigger installation
4. The manifest schema is the **flat schema** (do not use older nested shapes like `collections.current`).
5. Config generation has a single SSOT: `scripts/scaffold-configs.cjs`.

---

## Standard workflow (run from repo root)

All command paths below assume you run from the repo root.

### 0) Initialize state

```bash
node init/skills/initialize-project-from-requirements/scripts/init-pipeline.cjs start --repo-root .
```

### 1) Stage A: validate requirements docs -> user approval

```bash
node init/skills/initialize-project-from-requirements/scripts/init-pipeline.cjs check-docs \
  --repo-root . \
  --strict
```

Optional: update the must-ask checklist (for the state board; see the full key list in `init/skills/initialize-project-from-requirements/reference.md`):

```bash
node init/skills/initialize-project-from-requirements/scripts/init-pipeline.cjs mark-must-ask \
  --repo-root . \
  --key onePurpose \
  --asked \
  --answered \
  --written-to init/stage-a-docs/requirements.md
```

After the user reviews Stage A docs and explicitly says “approved”, run:

```bash
node init/skills/initialize-project-from-requirements/scripts/init-pipeline.cjs approve --stage A --repo-root .
```

### 2) Stage B: validate blueprint -> user approval

```bash
node init/skills/initialize-project-from-requirements/scripts/init-pipeline.cjs validate \
  --repo-root .
```

Optional: record that packs were reviewed (for the state board):

```bash
node init/skills/initialize-project-from-requirements/scripts/init-pipeline.cjs review-packs --repo-root .
```

After the user reviews the blueprint and explicitly approves, run:

```bash
node init/skills/initialize-project-from-requirements/scripts/init-pipeline.cjs approve --stage B --repo-root .
```

### 3) Stage C: write scaffold/configs/packs/wrappers -> user approval

```bash
node init/skills/initialize-project-from-requirements/scripts/init-pipeline.cjs apply \
  --repo-root . \
  --providers both
```

After the user reviews the changes and explicitly approves, run:

```bash
node init/skills/initialize-project-from-requirements/scripts/init-pipeline.cjs approve --stage C --repo-root .
```

### 4) Optional: remove the init kit

When the user confirms the bootstrap kit is no longer needed:

```bash
node init/skills/initialize-project-from-requirements/scripts/init-pipeline.cjs cleanup-init \
  --repo-root . \
  --apply \
  --i-understand
```

---

## Context Awareness add-on notes

### How it is triggered

To trigger add-on installation/init, set:
- `blueprint.addons.contextAwareness: true`

Optional (configuration only; does not trigger installation):
- `blueprint.context.mode: "contract" | "snapshot"` (default: `contract`)

### Key scripts (provided by the add-on)

- `.ai/scripts/contextctl.js`
  - `init`: initializes the `docs/context/` scaffold (idempotent)
- `.ai/scripts/projectctl.js`
  - `init`: initializes project state (idempotent)
  - `set-context-mode <contract|snapshot>`: sets the context mode
- `.ai/scripts/skillsctl.js` (scheme A)
  - `enable-pack <packId> --no-sync`: enables a pack (writes manifest)

---

## `addons/` directory convention (if needed)

This init pipeline supports add-ons in a minimally invasive way:

- Default add-on location: `/addons/context-awareness/payload/`
- `apply --addons-root <path>` changes the add-on root (for example, `third_party/addons`)

The payload is merged into the repo root using a “copy missing only” policy (non-destructive; does not overwrite existing files) to reduce the blast radius.

---

## DevOps scaffold (see `init/stages/03-stage-c-scaffold-and-skills.md`)

When any of these conditions are true, Stage C will create an `ops/` scaffold:

- `blueprint.quality.ci.enabled: true`
- `blueprint.quality.devops.*` is enabled
- `blueprint.devops.enabled: true` (or any sub-toggle)

Typical structure:
- `ops/packaging/{services,jobs,apps,scripts,workdocs}/`
- `ops/deploy/{http_services,workloads,clients,scripts,workdocs}/`

These are scaffolding placeholders (cloud/CI-agnostic) intended to be extended later.

---

## LLM-guided initialization

This skill supports an LLM (AI assistant) guiding the user through initialization without requiring the user to manually author configs up-front.

### Guidance docs

- `templates/llm-init-guide.md` - full guide for LLM-driven initialization
- `templates/conversation-prompts.md` - question bank and branching modules

### High-level flow

```
Phase 1: requirements interview -> Phase 2: tech stack selection -> Phase 3: blueprint generation
    -> Phase 4: add-on recommendations -> Phase 5: configuration generation -> run apply
```

### Phase 1–4: guided conversation

Follow the question order in `conversation-prompts.md`:

1. **Module A**: must-ask questions (needs, users, constraints)
2. **Module B**: branch modules (API, database, BPMN, CI)
3. **Module D**: add-on decisions
4. **Module E**: tech stack selection (language, frameworks, package manager)

### Phase 5: configuration generation

#### Languages with built-in templates

For these languages, the `apply` command can generate config via built-in templates:

| Language | Template directory |
|----------|--------------------|
| TypeScript/JavaScript | `scaffold-configs/typescript-pnpm/` |
| Go | `scaffold-configs/go/` |
| C/C++ | `scaffold-configs/cpp-xmake/` |
| React Native | `scaffold-configs/react-native-typescript/` |

#### Languages without built-in templates (LLM-generated)

For these languages, the LLM should generate configs based on `llm-init-guide.md`:

- Python -> `pyproject.toml`, directory layout
- Java -> `build.gradle.kts` or `pom.xml`
- Kotlin -> `build.gradle.kts`
- .NET -> `*.csproj`, `global.json`
- Rust -> `Cargo.toml`
- Other -> follow the language’s standard tooling conventions

**LLM generation flow**:

1. `apply` detects that no template exists and prints guidance
2. The LLM reads `blueprint.repo.language` and related framework/tooling choices
3. Use Phase 5 in `llm-init-guide.md` as the rulebook
4. Generate the needed config files and minimal directory structure
5. After user confirmation, continue the pipeline

### Example conversation (short)

```
AI: Let's start initializing your project. First, in one sentence: what problem does this project solve?

User: An inventory management system for small businesses.

AI: Great. Who are the primary users, and what are the must-have features?

User: Warehouse managers. Must-have: inbound/outbound inventory, inventory queries, alerts.

AI: Got it. What is the primary language?

User: Python

AI: Python has no built-in template here, so I will generate configuration files...
```

---

## References

- `templates/llm-init-guide.md` - LLM guidance
- `templates/conversation-prompts.md` - question bank
- `templates/project-blueprint.schema.json` - blueprint JSON schema
- `templates/project-blueprint.example.json` - full example
- `templates/project-blueprint.min.example.json` - minimal example
- `reference.md` - technical reference
