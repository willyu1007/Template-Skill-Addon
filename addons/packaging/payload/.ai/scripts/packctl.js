#!/usr/bin/env node
/**
 * packctl.js - Packaging Management
 *
 * Manages container and artifact packaging configuration.
 *
 * Commands:
 *   init           Initialize packaging structure (idempotent)
 *   add-service    Register a service for packaging
 *   add-job        Register a job/batch process
 *   remove-target  Remove a packaging target
 *   list           List all packaging targets
 *   build          Build a specific target (placeholder)
 *   build-all      Build all targets (placeholder)
 *   verify         Verify packaging configuration
 *   help           Show this help message
 */

import { existsSync, mkdirSync, readFileSync, writeFileSync, copyFileSync } from 'node:fs';
import { resolve, dirname, join, basename } from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// ─────────────────────────────────────────────────────────────────────────────
// Configuration
// ─────────────────────────────────────────────────────────────────────────────

const PACKAGING_DIR = 'ops/packaging';
const SERVICES_DIR = 'ops/packaging/services';
const JOBS_DIR = 'ops/packaging/jobs';
const APPS_DIR = 'ops/packaging/apps';
const TEMPLATES_DIR = 'ops/packaging/templates';
const SCRIPTS_DIR = 'ops/packaging/scripts';
const WORKDOCS_DIR = 'ops/packaging/workdocs';
const REGISTRY_FILE = 'docs/packaging/registry.json';

// ─────────────────────────────────────────────────────────────────────────────
// Utilities
// ─────────────────────────────────────────────────────────────────────────────

function parseArgs(args) {
  const result = { _: [], flags: {} };
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg.startsWith('--')) {
      const key = arg.slice(2);
      const nextArg = args[i + 1];
      if (nextArg && !nextArg.startsWith('--')) {
        result.flags[key] = nextArg;
        i++;
      } else {
        result.flags[key] = true;
      }
    } else {
      result._.push(arg);
    }
  }
  return result;
}

function resolveRepoRoot(flagValue) {
  if (flagValue) return resolve(flagValue);
  return resolve(__dirname, '..', '..');
}

function isoNow() {
  return new Date().toISOString().replace(/\.\d{3}Z$/, 'Z');
}

function ensureDir(dirPath) {
  if (!existsSync(dirPath)) {
    mkdirSync(dirPath, { recursive: true });
    return true;
  }
  return false;
}

function loadJson(filePath) {
  if (!existsSync(filePath)) return null;
  try {
    return JSON.parse(readFileSync(filePath, 'utf8'));
  } catch (e) {
    console.error(`Error reading ${filePath}: ${e.message}`);
    return null;
  }
}

function saveJson(filePath, data) {
  ensureDir(dirname(filePath));
  writeFileSync(filePath, JSON.stringify(data, null, 2));
}

function loadRegistry(repoRoot) {
  return loadJson(join(repoRoot, REGISTRY_FILE));
}

function saveRegistry(repoRoot, registry) {
  registry.updatedAt = isoNow();
  saveJson(join(repoRoot, REGISTRY_FILE), registry);
}

// ─────────────────────────────────────────────────────────────────────────────
// Dockerfile Templates
// ─────────────────────────────────────────────────────────────────────────────

const DOCKERFILE_NODE = `# Node.js Dockerfile
# Generated by packctl.js

FROM node:20-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

FROM node:20-alpine
WORKDIR /app
COPY --from=builder /app/node_modules ./node_modules
COPY . .

USER node
EXPOSE 3000
CMD ["node", "dist/index.js"]
`;

const DOCKERFILE_PYTHON = `# Python Dockerfile
# Generated by packctl.js

FROM python:3.12-slim AS builder
WORKDIR /app
COPY requirements.txt ./
RUN pip install --user --no-cache-dir -r requirements.txt

FROM python:3.12-slim
WORKDIR /app
COPY --from=builder /root/.local /root/.local
COPY . .

ENV PATH=/root/.local/bin:$PATH
EXPOSE 8000
CMD ["python", "-m", "uvicorn", "main:app", "--host", "0.0.0.0"]
`;

const DOCKERFILE_GO = `# Go Dockerfile
# Generated by packctl.js

FROM golang:1.22-alpine AS builder
WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -o /app/main .

FROM alpine:3.19
WORKDIR /app
COPY --from=builder /app/main .

USER nobody
EXPOSE 8080
CMD ["./main"]
`;

// ─────────────────────────────────────────────────────────────────────────────
// Commands
// ─────────────────────────────────────────────────────────────────────────────

function cmdInit(repoRoot) {
  console.log(`Initializing packaging at ${repoRoot}...`);
  let created = false;

  // Create directories
  const dirs = [PACKAGING_DIR, SERVICES_DIR, JOBS_DIR, APPS_DIR, TEMPLATES_DIR, SCRIPTS_DIR, WORKDOCS_DIR];
  for (const dir of dirs) {
    const fullPath = join(repoRoot, dir);
    if (ensureDir(fullPath)) {
      console.log(`  Created: ${dir}/`);
      created = true;
    }
  }

  // Create registry
  const registryPath = join(repoRoot, REGISTRY_FILE);
  if (!existsSync(registryPath)) {
    const initialRegistry = {
      version: 1,
      updatedAt: isoNow(),
      targets: []
    };
    saveJson(registryPath, initialRegistry);
    console.log(`  Created: ${REGISTRY_FILE}`);
    created = true;
  }

  // Create Dockerfile templates
  const templates = [
    { name: 'Dockerfile.node', content: DOCKERFILE_NODE },
    { name: 'Dockerfile.python', content: DOCKERFILE_PYTHON },
    { name: 'Dockerfile.go', content: DOCKERFILE_GO }
  ];

  for (const t of templates) {
    const tPath = join(repoRoot, TEMPLATES_DIR, t.name);
    if (!existsSync(tPath)) {
      writeFileSync(tPath, t.content);
      console.log(`  Created: ${TEMPLATES_DIR}/${t.name}`);
      created = true;
    }
  }

  // Create AGENTS.md
  const agentsPath = join(repoRoot, PACKAGING_DIR, 'AGENTS.md');
  if (!existsSync(agentsPath)) {
    const agentsContent = `# Packaging - AI Guidance

## Conclusions (read first)

- \`ops/packaging/\` contains all containerization artifacts.
- Use \`packctl.js\` to manage packaging configuration.
- AI proposes changes; humans execute builds.

## Directory Structure

- \`services/\` - Service Dockerfiles (long-running)
- \`jobs/\` - Job Dockerfiles (batch/cron)
- \`apps/\` - Application Dockerfiles (CLI tools, etc.)
- \`templates/\` - Dockerfile templates by language
- \`scripts/\` - Build helper scripts

## AI Workflow

1. **Register** targets: \`node .ai/scripts/packctl.js add-service --id <id> --module <path>\`
2. **Customize** Dockerfile if needed (in appropriate directory)
3. **Document** decisions in \`workdocs/\`
4. **Request human** to build and push

## Build Commands (Human)

\`\`\`bash
docker build -f ops/packaging/services/<name>.Dockerfile -t <registry>/<name>:<tag> .
docker push <registry>/<name>:<tag>
\`\`\`
`;
    writeFileSync(agentsPath, agentsContent);
    console.log(`  Created: ${PACKAGING_DIR}/AGENTS.md`);
    created = true;
  }

  // Create workdocs README
  const workdocsReadme = join(repoRoot, WORKDOCS_DIR, 'README.md');
  if (!existsSync(workdocsReadme)) {
    writeFileSync(workdocsReadme, '# Packaging Workdocs\n\nUse this directory for packaging plans and notes.\n');
    console.log(`  Created: ${WORKDOCS_DIR}/README.md`);
    created = true;
  }

  // Create .gitkeep files
  for (const dir of [SERVICES_DIR, JOBS_DIR, APPS_DIR, SCRIPTS_DIR]) {
    const gitkeep = join(repoRoot, dir, '.gitkeep');
    if (!existsSync(gitkeep)) {
      writeFileSync(gitkeep, '');
    }
  }

  if (!created) {
    console.log('  Packaging already initialized (no changes).');
  }

  console.log('Done.');
  return 0;
}

function cmdAddService(repoRoot, flags) {
  const { id, module } = flags;

  if (!id) {
    console.error('Error: --id is required.');
    return 1;
  }

  const registry = loadRegistry(repoRoot);
  if (!registry) {
    console.error('Error: Registry not found. Run `packctl init` first.');
    return 1;
  }

  if (registry.targets.some(t => t.id === id)) {
    console.error(`Error: Target "${id}" already exists.`);
    return 1;
  }

  const dockerfile = `${SERVICES_DIR}/${id}.Dockerfile`;
  const target = {
    id,
    type: 'service',
    module: module || `apps/${id}`,
    dockerfile,
    createdAt: isoNow()
  };

  registry.targets.push(target);
  saveRegistry(repoRoot, registry);

  // Create a basic Dockerfile if it doesn't exist
  const dockerfilePath = join(repoRoot, dockerfile);
  if (!existsSync(dockerfilePath)) {
    writeFileSync(dockerfilePath, DOCKERFILE_NODE);
    console.log(`  Created: ${dockerfile}`);
  }

  console.log(`Added service: ${id}`);
  console.log(`  module: ${target.module}`);
  console.log(`  dockerfile: ${dockerfile}`);
  return 0;
}

function cmdAddJob(repoRoot, flags) {
  const { id, module } = flags;

  if (!id) {
    console.error('Error: --id is required.');
    return 1;
  }

  const registry = loadRegistry(repoRoot);
  if (!registry) {
    console.error('Error: Registry not found. Run `packctl init` first.');
    return 1;
  }

  if (registry.targets.some(t => t.id === id)) {
    console.error(`Error: Target "${id}" already exists.`);
    return 1;
  }

  const dockerfile = `${JOBS_DIR}/${id}.Dockerfile`;
  const target = {
    id,
    type: 'job',
    module: module || `jobs/${id}`,
    dockerfile,
    createdAt: isoNow()
  };

  registry.targets.push(target);
  saveRegistry(repoRoot, registry);

  // Create a basic Dockerfile
  const dockerfilePath = join(repoRoot, dockerfile);
  if (!existsSync(dockerfilePath)) {
    writeFileSync(dockerfilePath, DOCKERFILE_NODE);
    console.log(`  Created: ${dockerfile}`);
  }

  console.log(`Added job: ${id}`);
  return 0;
}

function cmdRemoveTarget(repoRoot, flags) {
  const { id } = flags;

  if (!id) {
    console.error('Error: --id is required.');
    return 1;
  }

  const registry = loadRegistry(repoRoot);
  if (!registry) {
    console.error('Error: Registry not found.');
    return 1;
  }

  const idx = registry.targets.findIndex(t => t.id === id);
  if (idx === -1) {
    console.error(`Error: Target "${id}" not found.`);
    return 1;
  }

  registry.targets.splice(idx, 1);
  saveRegistry(repoRoot, registry);

  console.log(`Removed target: ${id}`);
  console.log('Note: Dockerfile not deleted. Remove manually if needed.');
  return 0;
}

function cmdList(repoRoot) {
  const registry = loadRegistry(repoRoot);
  if (!registry) {
    console.error('Error: Registry not found.');
    return 1;
  }

  if (registry.targets.length === 0) {
    console.log('No packaging targets registered.');
    return 0;
  }

  console.log(`Packaging targets (${registry.targets.length}):\n`);
  for (const t of registry.targets) {
    console.log(`  ${t.id} (${t.type})`);
    console.log(`    module: ${t.module}`);
    console.log(`    dockerfile: ${t.dockerfile}`);
    console.log();
  }
  return 0;
}

function cmdBuild(repoRoot, flags) {
  const { target, tag } = flags;

  if (!target) {
    console.error('Error: --target is required.');
    return 1;
  }

  const registry = loadRegistry(repoRoot);
  if (!registry) {
    console.error('Error: Registry not found.');
    return 1;
  }

  const t = registry.targets.find(x => x.id === target);
  if (!t) {
    console.error(`Error: Target "${target}" not found.`);
    return 1;
  }

  console.log(`\n⚠️  Build is a placeholder. In production, this would run:`);
  console.log(`\ndocker build -f ${t.dockerfile} -t ${target}:${tag || 'latest'} .`);
  console.log(`\nTo build manually, run the above command from the repository root.`);
  return 0;
}

function cmdVerify(repoRoot) {
  const registry = loadRegistry(repoRoot);
  if (!registry) {
    console.error('Error: Registry not found.');
    return 1;
  }

  console.log('Verifying packaging configuration...');
  let errors = 0;

  for (const t of registry.targets) {
    const dockerfilePath = join(repoRoot, t.dockerfile);
    if (!existsSync(dockerfilePath)) {
      console.error(`  ERROR: Dockerfile not found: ${t.dockerfile} (target: ${t.id})`);
      errors++;
    } else {
      console.log(`  OK: ${t.id} - ${t.dockerfile}`);
    }
  }

  if (errors > 0) {
    console.error(`\nVerification FAILED: ${errors} error(s).`);
    return 1;
  }

  console.log(`\nVerification passed: ${registry.targets.length} target(s) OK.`);
  return 0;
}

function cmdHelp() {
  console.log(`
packctl.js - Packaging Management

Usage: node .ai/scripts/packctl.js <command> [options]

Commands:
  init              Initialize packaging structure (idempotent)
  
  add-service       Register a service for packaging
    --id <id>       Target identifier (required)
    --module <path> Module path (default: apps/<id>)
    
  add-job           Register a job/batch process
    --id <id>       Target identifier (required)
    --module <path> Module path (default: jobs/<id>)
    
  remove-target     Remove a packaging target
    --id <id>       Target identifier (required)
    
  list              List all packaging targets
  
  build             Build a specific target (placeholder)
    --target <id>   Target to build (required)
    --tag <tag>     Image tag (default: latest)
    
  verify            Verify packaging configuration
  
  help              Show this help message

Global Options:
  --repo-root <path>  Repository root (default: auto-detect)

Examples:
  node .ai/scripts/packctl.js init
  node .ai/scripts/packctl.js add-service --id api --module apps/backend
  node .ai/scripts/packctl.js add-job --id cron-task
  node .ai/scripts/packctl.js list
`);
  return 0;
}

// ─────────────────────────────────────────────────────────────────────────────
// Main
// ─────────────────────────────────────────────────────────────────────────────

function main() {
  const args = process.argv.slice(2);
  const parsed = parseArgs(args);
  const command = parsed._[0] || 'help';
  const repoRoot = resolveRepoRoot(parsed.flags['repo-root']);

  switch (command) {
    case 'init':
      return cmdInit(repoRoot);
    case 'add-service':
      return cmdAddService(repoRoot, parsed.flags);
    case 'add-job':
      return cmdAddJob(repoRoot, parsed.flags);
    case 'remove-target':
      return cmdRemoveTarget(repoRoot, parsed.flags);
    case 'list':
      return cmdList(repoRoot);
    case 'build':
      return cmdBuild(repoRoot, parsed.flags);
    case 'build-all':
      console.log('Building all targets...');
      return cmdList(repoRoot);
    case 'verify':
      return cmdVerify(repoRoot);
    case 'help':
    case '--help':
    case '-h':
      return cmdHelp();
    default:
      console.error(`Unknown command: ${command}`);
      return cmdHelp() || 1;
  }
}

process.exit(main());

